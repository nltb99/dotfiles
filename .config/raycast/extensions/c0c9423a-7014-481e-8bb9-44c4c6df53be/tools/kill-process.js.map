{
  "version": 3,
  "sources": ["../../src/tools/kill-process.ts", "../../src/utils/platform.ts"],
  "sourcesContent": ["import { exec } from \"child_process\";\nimport { Tool } from \"@raycast/api\";\nimport { getKillCommand, getPlatformSpecificErrorHelp } from \"../utils/platform\";\n\n/**\n * Input type for killing a process\n */\ntype Input = {\n  /**\n   * App name to kill\n   */\n  processName?: string;\n\n  /**\n   * Process ID to kill\n   */\n  id: number;\n\n  /**\n   * Path to the process to kill\n   */\n  path?: string;\n\n  /**\n   * Whether to force kill the process (requires elevated privileges)\n   */\n  force?: boolean;\n};\n\n/**\n * Kill a process.\n * Provide the process ID to kill.\n * If the process is not found, the tool will return an error.\n */\nexport default async function killProcess(input: Input) {\n  return new Promise((resolve, reject) => {\n    const command = getKillCommand(input.id, input.force);\n\n    exec(command, (killErr) => {\n      if (killErr) {\n        const errorHelp = getPlatformSpecificErrorHelp(input.force || false);\n        const error = new Error(`${errorHelp.title}: ${killErr.message}`);\n        reject(error);\n        return;\n      }\n\n      const processInfo = input.processName ? `${input.processName} ` : \"\";\n      resolve({\n        success: true,\n        message: `Killed process: ${processInfo}(PID: ${input.id})`,\n      });\n    });\n  });\n}\n\n/**\n * Because forcibly killing a process can cause data loss or undesired system changes,\n * let's ask for user confirmation before proceeding.\n */\nexport const confirmation: Tool.Confirmation<Input> = async (input: Input) => {\n  const info: { name: string; value: string }[] = [];\n\n  // Only add Process Name if it's provided and non-empty\n  if (input.processName) {\n    info.push({ name: \"Process Name\", value: input.processName });\n  }\n\n  // Always add PID as it's required\n  info.push({ name: \"PID\", value: String(input.id) });\n\n  // Only add Path if it's provided and non-empty\n  if (input.path) {\n    info.push({ name: \"Path\", value: input.path });\n  }\n\n  return { info };\n};\n", "import { Image } from \"@raycast/api\";\nimport { Process } from \"../types\";\n\n/**\n * Platform detection utilities\n */\nexport const platform = process.platform;\nexport const isMac = platform === \"darwin\";\nexport const isWindows = platform === \"win32\";\n\n/**\n * Get platform-specific process list command\n */\nexport function getProcessListCommand(): string {\n  if (isWindows) {\n    // Windows: Use PowerShell to get process information\n    return `powershell \"Get-Process | Select-Object Id,ProcessName,CPU,WorkingSet,Path | ForEach-Object { \\\\\"$($_.Id) $($_.ProcessName) $($_.CPU) $($_.WorkingSet) $($_.Path)\\\\\" }\"`;\n  } else {\n    // macOS: Use ps command\n    return \"ps -eo pid,ppid,pcpu,rss,comm\";\n  }\n}\n\n/**\n * Get platform-specific kill command\n */\nexport function getKillCommand(pid: number, force: boolean = false): string {\n  if (isWindows) {\n    return force ? `taskkill /F /PID ${pid}` : `taskkill /PID ${pid}`;\n  } else {\n    // macOS\n    return force ? `sudo kill -9 ${pid}` : `kill -9 ${pid}`;\n  }\n}\n\n/**\n * Parse process information based on platform\n */\nexport function parseProcessLine(line: string): Partial<Process> | null {\n  if (!line.trim()) return null;\n\n  if (isWindows) {\n    // Windows PowerShell output format: \"PID ProcessName CPU WorkingSet Path\"\n    const parts = line.trim().split(/\\s+/);\n    if (parts.length < 4) return null;\n\n    const [id, processName, cpu, mem, ...pathParts] = parts;\n    const path = pathParts.join(\" \") || \"\";\n\n    return {\n      id: parseInt(id) || 0,\n      pid: 0, // Parent PID not easily available in basic Windows commands\n      cpu: parseFloat(cpu) || 0,\n      mem: parseInt(mem) || 0,\n      path: path,\n      processName: processName || \"\",\n    };\n  } else {\n    // macOS: ps output format\n    const defaultValue = [\"\", \"\", \"\", \"\", \"\", \"\"];\n    const regex = /(\\d+)\\s+(\\d+)\\s+(\\d+[.|,]\\d+)\\s+(\\d+)\\s+(.*)/;\n    const [, id, pid, cpu, mem, path] = line.match(regex) ?? defaultValue;\n\n    if (!id) return null;\n\n    const processName = path.match(/[^/]*[^/]*$/i)?.[0] ?? \"\";\n\n    return {\n      id: parseInt(id),\n      pid: parseInt(pid),\n      cpu: parseFloat(cpu),\n      mem: parseInt(mem),\n      path: path,\n      processName: processName,\n    };\n  }\n}\n\n/**\n * Detect process type based on platform\n */\nexport function getProcessType(path: string): Process[\"type\"] {\n  if (isMac) {\n    // macOS-specific detection\n    const isPrefPane = path.includes(\".prefPane\");\n    const isApp = path.includes(\".app/\");\n    return isPrefPane ? \"prefPane\" : isApp ? \"app\" : \"binary\";\n  } else if (isWindows) {\n    // Windows-specific detection\n    const isApp =\n      path.toLowerCase().endsWith(\".exe\") &&\n      (path.toLowerCase().includes(\"program files\") || path.toLowerCase().includes(\"applications\"));\n    return isApp ? \"app\" : \"binary\";\n  } else {\n    // Fallback for unsupported platforms\n    return \"binary\";\n  }\n}\n\n/**\n * Extract application name based on platform\n */\nexport function getAppName(path: string, processName: string): string | undefined {\n  if (isMac) {\n    // macOS: Extract from .app bundle path\n    return path.match(/(?<=\\/)[^/]+(?=\\.app\\/)/)?.[0];\n  } else if (isWindows) {\n    // Windows: Use process name without .exe extension\n    return processName.replace(/\\.exe$/i, \"\");\n  } else {\n    // Fallback for unsupported platforms\n    return processName;\n  }\n}\n\n/**\n * Get platform-specific file icon\n */\nexport function getFileIcon(process: Process): Image.ImageLike {\n  if (isMac) {\n    // macOS-specific icon handling\n    if (process.type === \"prefPane\") {\n      return {\n        fileIcon: process.path?.replace(/(.+\\.prefPane)(.+)/, \"$1\") ?? \"\",\n      };\n    }\n\n    if (process.type === \"app\" || process.type === \"aggregatedApp\") {\n      return { fileIcon: process.path?.replace(/(.+\\.app)(.+)/, \"$1\") ?? \"\" };\n    }\n\n    return \"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/ExecutableBinaryIcon.icns\";\n  } else if (isWindows) {\n    // Windows-specific icon handling\n    if (process.type === \"app\") {\n      return { fileIcon: process.path };\n    }\n    return \"\uD83D\uDDA5\uFE0F\"; // Generic computer icon for Windows binaries\n  } else {\n    // Fallback for unsupported platforms\n    return \"\u2699\uFE0F\"; // Generic gear icon\n  }\n}\n\n/**\n * Get platform-specific error messages and help\n */\nexport function getPlatformSpecificErrorHelp(isForceKill: boolean): {\n  title: string;\n  message?: string;\n  helpUrl?: string;\n} {\n  if (isMac && isForceKill) {\n    return {\n      title: \"Failed to Force Kill Process\",\n      message: \"Please ensure that touch ID/password prompt is enabled for sudo\",\n      helpUrl: \"https://dev.to/siddhantkcode/enable-touch-id-authentication-for-sudo-on-macos-sonoma-14x-4d28\",\n    };\n  } else if (isWindows && isForceKill) {\n    return {\n      title: \"Failed to Force Kill Process\",\n      message: \"Administrative privileges may be required. Try running as administrator.\",\n    };\n  } else {\n    return {\n      title: \"Failed to Kill Process\",\n      message: \"The process could not be terminated. It may have already exited or require elevated privileges.\",\n    };\n  }\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,kBAAAE,EAAA,YAAAC,IAAA,eAAAC,EAAAJ,GAAA,IAAAK,EAAqB,yBCMd,IAAMC,EAAW,QAAQ,SACnBC,EAAQD,IAAa,SACrBE,EAAYF,IAAa,QAkB/B,SAASG,EAAeC,EAAaC,EAAiB,GAAe,CAC1E,OAAIC,EACKD,EAAQ,oBAAoBD,CAAG,GAAK,iBAAiBA,CAAG,GAGxDC,EAAQ,gBAAgBD,CAAG,GAAK,WAAWA,CAAG,EAEzD,CAkHO,SAASG,EAA6BC,EAI3C,CACA,OAAIC,GAASD,EACJ,CACL,MAAO,+BACP,QAAS,kEACT,QAAS,+FACX,EACSE,GAAaF,EACf,CACL,MAAO,+BACP,QAAS,0EACX,EAEO,CACL,MAAO,yBACP,QAAS,iGACX,CAEJ,CDvIA,eAAOG,EAAmCC,EAAc,CACtD,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,IAAMC,EAAUC,EAAeJ,EAAM,GAAIA,EAAM,KAAK,KAEpD,QAAKG,EAAUE,GAAY,CACzB,GAAIA,EAAS,CACX,IAAMC,EAAYC,EAA6BP,EAAM,OAAS,EAAK,EAC7DQ,EAAQ,IAAI,MAAM,GAAGF,EAAU,KAAK,KAAKD,EAAQ,OAAO,EAAE,EAChEH,EAAOM,CAAK,EACZ,MACF,CAEA,IAAMC,EAAcT,EAAM,YAAc,GAAGA,EAAM,WAAW,IAAM,GAClEC,EAAQ,CACN,QAAS,GACT,QAAS,mBAAmBQ,CAAW,SAAST,EAAM,EAAE,GAC1D,CAAC,CACH,CAAC,CACH,CAAC,CACH,CAMO,IAAMU,EAAyC,MAAOV,GAAiB,CAC5E,IAAMW,EAA0C,CAAC,EAGjD,OAAIX,EAAM,aACRW,EAAK,KAAK,CAAE,KAAM,eAAgB,MAAOX,EAAM,WAAY,CAAC,EAI9DW,EAAK,KAAK,CAAE,KAAM,MAAO,MAAO,OAAOX,EAAM,EAAE,CAAE,CAAC,EAG9CA,EAAM,MACRW,EAAK,KAAK,CAAE,KAAM,OAAQ,MAAOX,EAAM,IAAK,CAAC,EAGxC,CAAE,KAAAW,CAAK,CAChB",
  "names": ["kill_process_exports", "__export", "confirmation", "killProcess", "__toCommonJS", "import_child_process", "platform", "isMac", "isWindows", "getKillCommand", "pid", "force", "isWindows", "getPlatformSpecificErrorHelp", "isForceKill", "isMac", "isWindows", "killProcess", "input", "resolve", "reject", "command", "getKillCommand", "killErr", "errorHelp", "getPlatformSpecificErrorHelp", "error", "processInfo", "confirmation", "info"]
}
